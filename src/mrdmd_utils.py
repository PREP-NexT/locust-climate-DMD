import matplotlib.pyplot as plt
import numpy as np
from numpy import dot, multiply, diag, pi
from numpy.linalg import inv, eig, solve
from scipy.linalg import svd, svdvals
from math import floor, ceil  # python 3.x
import pandas as pd

from plot_utils import *


def svht(X, sv=None):
    """
    This function is adapted from Robert Taylor's blog (http://www.pyrunner.com/weblog/2016/08/05/mrdmd-python/).
    """
    # svht for sigma unknown
    m, n = sorted(X.shape)  # ensures m <= n
    beta = m / n  # ratio between 0 and 1
    if sv is None:
        sv = svdvals(X)
    sv = np.squeeze(sv)
    omega_approx = 0.56 * beta ** 3 - 0.95 * beta ** 2 + 1.82 * beta + 1.43
    return np.median(sv) * omega_approx


def dmd(X, Y, truncate=None):
    """
    This function is adapted from Robert Taylor's blog (http://www.pyrunner.com/weblog/2016/08/05/mrdmd-python/) and
    the book Data driven science & engineering (http://www.databookuw.com/).
    """
    if truncate == 0:
        # return empty vectors
        mu = np.array([], dtype='complex')
        Phi = np.zeros([X.shape[0], 0], dtype='complex')
    else:
        U2, Sig2, Vh2 = svd(X, False)  # SVD of input matrix
        r = len(Sig2) if truncate is None else truncate  # rank truncation
        U = U2[:, :r]
        Sig = diag(Sig2)[:r, :r]
        V = Vh2.conj().T[:, :r]
        Atil = dot(dot(dot(U.conj().T, Y), V), inv(Sig))  # build A tilde
        mu, W = eig(Atil)
        Phi = dot(dot(dot(Y, V), inv(Sig)), W)  # build DMD modes
    return mu, Phi


def mrdmd(D, level=0, bin_num=0, offset=0, max_levels=7, max_cycles=2, do_svht=True):
    """
    This function is adapted from Robert Taylor's blog (http://www.pyrunner.com/weblog/2016/08/05/mrdmd-python/).

    Compute the multi-resolution DMD on the dataset `D`, returning a list of nodes
    in the hierarchy. Each node represents a particular "time bin" (window in time) at
    a particular "level" of the recursion (time scale). The node is an object consisting
    of the various data structures generated by the DMD at its corresponding level and
    time bin. The `level`, `bin_num`, and `offset` parameters are for record keeping
    during the recursion and should not be modified unless you know what you are doing.
    The `max_levels` parameter controls the maximum number of levels. The `max_cycles`
    parameter controls the maximum number of mode oscillations in any given time scale
    that qualify as "slow". The `do_svht` parameter indicates whether or not to perform
    optimal singular value hard thresholding."""

    # 4 times nyquist limit to capture cycles
    # nyq = 8 * max_cycles

    # time bin size
    bin_size = D.shape[1]
    # if bin_size < nyq:
    #     return []

    # extract subsamples
    # step = floor(bin_size / nyq)  # max step size to capture cycles
    # # _D = D[:, ::step]
    # X = _D[:, :-1]
    # Y = _D[:, 1:]

    X = D[:, :-1]
    Y = D[:, 1:]

    # determine rank-reduction
    if do_svht:
        sv = svdvals(D)
        tau = svht(D, sv=sv)
        r = sum(sv > tau)
    else:
        r = min(X.shape)

    # compute dmd
    sLambda, Phi = dmd(X, Y, r)
    # frequency cutoff (oscillations per timestep)
    rho = max_cycles / bin_size

    # consolidate slow eigenvalues (as boolean mask)
    # slow = (np.abs(np.log(sLambda) / (2 * pi))) <= rho
    # The ONLY difference between mrDMD_noSampling.py and mrDMD_noSampling_rho.py!!!
    slow = np.abs(np.imag(np.log(sLambda) / (2 * pi))) <= rho
    n = sum(slow)  # number of slow modes

    # extract slow modes (perhaps empty)
    sLambda = sLambda[slow]
    Phi = Phi[:, slow]

    if n > 0:
        # vars for the objective function for D (before subsampling)
        Vand = np.vander(sLambda, bin_size, True)
        P = multiply(dot(Phi.conj().T, Phi), np.conj(dot(Vand, Vand.conj().T)))
        q = np.conj(diag(dot(dot(Vand, D.conj().T), Phi)))
        # find optimal b solution
        b_opt = solve(P, q).squeeze()
        # time evolution
        Psi = (Vand.T * b_opt).T
    else:
        # zero time evolution
        b_opt = np.array([], dtype='complex')
        Psi = np.zeros([0, bin_size], dtype='complex')

    # dmd reconstruction
    D_dmd = dot(Phi, Psi)

    # remove influence of slow modes
    D = D - D_dmd

    # record keeping
    node = type('Node', (object,), {})()
    node.level = level  # level of recursion
    node.bin_num = bin_num  # time bin number
    node.bin_size = bin_size  # time bin size
    node.start = offset  # starting index
    node.stop = offset + bin_size  # stopping index
    # node.step = step  # step size
    node.rho = rho  # frequency cutoff
    node.r = r  # rank-reduction
    node.n = n  # number of extracted modes
    node.sLambda = sLambda  # extracted eigenvalues
    node.Phi = Phi  # extracted DMD modes
    node.Psi = Psi  # extracted time evolution
    node.b_opt = b_opt  # extracted optimal b vector
    nodes = [node]

    # split data into two and do recursion
    if level < max_levels:
        split = ceil(bin_size / 2)  # where to split
        nodes += mrdmd(
            D[:, :split],
            level=level + 1,
            bin_num=2 * bin_num,
            offset=offset,
            max_levels=max_levels,
            max_cycles=max_cycles,
            do_svht=do_svht
        )
        nodes += mrdmd(
            D[:, split:],
            level=level + 1,
            bin_num=2 * bin_num + 1,
            offset=offset + split,
            max_levels=max_levels,
            max_cycles=max_cycles,
            do_svht=do_svht
        )

    return nodes


def stitch(nodes, level):
    """
        This function is adapted from Robert Taylor's blog (http://www.pyrunner.com/weblog/2016/08/05/mrdmd-python/).
    """
    # get length of time dimension
    start = min([nd.start for nd in nodes])
    stop = max([nd.stop for nd in nodes])
    t = stop - start

    # extract relevant nodes
    nodes = [n for n in nodes if n.level == level]
    nodes = sorted(nodes, key=lambda n: n.bin_num)

    # stack DMD modes
    Phi = np.hstack([n.Phi for n in nodes])

    # allocate zero matrix for time evolution
    nmodes = sum([n.n for n in nodes])
    Psi = np.zeros([nmodes, t], dtype='complex')

    # copy over time evolution for each time bin
    i = 0
    for n in nodes:
        _nmodes = n.Psi.shape[0]
        Psi[i:i + _nmodes, n.start:n.stop] = n.Psi
        i += _nmodes

    return Phi, Psi


def mode_selection(m, lmbd, Phi, dt=1, plot=None):
    """
        Mode selection to find out modes with highest power.

    [V 2021.08.26] Created, both climatic and locust variables can use.
    :param plot: choose to plot semi-log or normal extent. Default is None, i.e., no plot.
    :param m: the order of eigenvalue for normalization
    :param lmbd: eigenvalue for normalization
    :param Phi: eigenvectors
    :param dt: dt=1
    :return: df with frequency, period, and sorted power (p) for mode selection
    """
    p = np.array([abs(lmbd[i] ** m) * np.linalg.norm(Phi[:, i]) for i in range(len(lmbd))])
    freq_positive = 12 * abs(np.imag(np.log(lmbd)) / (2 * np.pi * dt))  # unit: [1/yr]
    period = 1 / freq_positive
    df = pd.DataFrame(np.stack((freq_positive, p, period), axis=-1),
                      columns=['Frequency', f'power(m={m})', 'period'])
    df.sort_values(by=[f'power(m={m})'], inplace=True, ascending=False)
    # plot
    if plot == 'log':
        # semi-log
        fig, ax = plt.subplots(figsize=(8, 5))
        # plt.xticks(rotation=90)
        ax.stem(freq_positive, p, markerfmt='r.')  # CANNOT without bottom
        ax.set_ylim(0.9 * min(p), 1.2 * max(p))
        ax.set_yscale('log')
        ax.set_title('Mode selection')
        ax.set_xlabel("Frequency (1/yr)")
        ax.set_ylabel(f"Power (m={m})")
        plt.show()
    elif plot == 'normal':
        # normal
        fig, ax = plt.subplots(figsize=(8, 5))
        # plt.xticks(rotation=90)
        ax.stem(freq_positive, p, markerfmt='r.')  # CANNOT without bottom
        ax.set_ylim(0, 1.2 * max(p))
        # ax.set_yscale('log')
        ax.set_title('Mode selection')
        ax.set_xlabel("Frequency (1/yr)")
        ax.set_ylabel(f"Power (m={m})")
        plt.show()
    return df


def get_1yr_mode(locust_type, Phi0_lo, period0_lo):
    """
        Retrieve the locust mode close to 1 year period (and its exact period).
        The desired period (which is named "want" below) is predefined by mode selection.

    :param locust_type: which locust_type
    :param Phi0_lo: All modes in Level 0.
    :param period0_lo: The periods of all modes in Level 0.
    :return: mode_locust, period_locust
    """
    if locust_type == 'all':
        want = 1.040
    elif locust_type == 'all_1st18y':
        want = 0.982
    elif locust_type == 'all_2nd18y':
        want = 0.989
    elif locust_type == 'Adults':
        want = 1.002
    elif locust_type == 'Hoppers':
        want = 0.987
    elif locust_type == 'Swarms':
        want = 1.033
    elif locust_type == "Bands":
        want = 1.086

    for i in range(len(period0_lo)):
        if np.abs(np.round(period0_lo[i], decimals=3) - want) < 1e-4:
            mode_locust = Phi0_lo[:, i]
            period_locust = period0_lo[i]
            # print(f'period_locust: {period_locust}')

    return mode_locust, period_locust


def mag_lo_ElLa(nodes_lo, ElLa='El', plot=False, Xlon=None, Ylat=None, nosea_indices_lo=None, savepath=None):
    """
        Get locust magnitude during El Nino events or La Nina events. with or without plotting.

    :param nodes_lo: All nodes retrieved from mrDMD.
    :param ElLa: 'El' for El Nino events, 'La' for La Nina events.
    :param plot: whether to plot or not.
    :param Xlon: only used when plotting. Available from load_data_locust().
    :param Ylat: only used when plotting. Available from load_data_locust().
    :param nosea_indices_lo: only used when plotting. Available from load_data_locust().
    :return: mag: magnitude during El Nino events or La Nina events.
    """
    nodes5 = [n for n in nodes_lo if n.level == 5]
    if ElLa == 'El':
        pattern = [nodes5[i] for i in [11, 27]]
    elif ElLa == 'La':
        pattern = [nodes5[i] for i in [12, 13, 23]]
    else:
        print('You must choose between El Nino or La Nina!')

    mag_sum = np.zeros(pattern[0].Phi[:, 0].shape)
    count = 0
    for i in range(len(pattern)):
        for j in range(len(pattern[i].sLambda)):
            if np.abs(np.imag(pattern[i].sLambda[j])) < 1e-14:
                count += 1
                freq = np.imag(np.log(pattern[i].sLambda[j])) / 2 / np.pi * 12
                period = 1 / freq
                mag_sum += np.abs(pattern[i].Phi[:, j])
                # print("\nLevel 5, time bin ", pattern[i].bin_num, "\nEigenvalue:", pattern[i].sLambda[j], '\nperiod:',
                #       period, '\nfrequency: ', freq)
    mag = mag_sum / count

    if plot:
        plot_mag_lo(mag=mag, Xlon=Xlon, Ylat=Ylat, nosea_indices=nosea_indices_lo, locust_type=ElLa, savepath=savepath)
    return mag
